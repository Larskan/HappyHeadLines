The overall todo
- C4 Diagram - Done
- C4 Diagram for all 4 levels - Do last
- Implement ArticleService with CRUD and REST API and x-axis with 3 instances and load balancer - Done
- Implement ArticleDatabase and y-axis so each continent has own DB + a global DB - Done
- Implement CommentService. Fault Isolated with swimlanes. Takes over if Profanity Fails - Done
- Implement CommentDatabase - Done
- Implement ProfanityService. Fault Isolated with swimlanes - Done
- Implement ProfanityDatabase.  - Done
---------------------------------------------
- Implement Draftservice with logging and tracing.
- Implement DraftDatabase with logging and tracing.
- Log and trace in central repo that is reuseable across entire architecture.
- Add automatic cleaning of logs.
- Implement PublisherService with focus on distributed tracing.
- Implement NewsletterService with focus on distributed tracing.
- Implement ArticleQueue
- Implement ArticleCache using offline process to periodically fill cache with articles from latest 14 days.
- Implement CommentCache using cache miss approach to fill cache. Limited to all comments from most recently 30 accessed articles, when its full, the LRU algorith is used to clean up the cache.
- Use Redis, because I want to learn how to use it.

Webapp: Publish an article.
PublisherService: Handles the publishing of articles, sends to ArticleQueue.
ArticleQueue: When an article is being published, the article enters the queue.
NewsletterService: Sends out newsletters to subscribers.
NewsletterService: Subscribes to ArticleQueue to receive the latest news first for immediate newsletter.
NewsletterService: Requests articles from ArticleService for daily newsletter, ArticleService fetch/stores articles in ArtibleDB.
ArticleService: Subscribes to ArticleQueue for the latest articles in order to persist them in a database.

Rewriting of the architecture
- Controller: The front desk, receives request, checks if valid and passes it to the right department.
- Controller: Deals with HTTP: Routing, query/body passing, response codes. 
- Controller: If client calls Post Articles, controller takes the ArticleDto from the body and gives it to the service.
- Service: The Manager, knows how to get work done, doesnt talk to DB directly, delegates to repo.
- Service: Business logic: rules, orchestration, validation.
- Service: Examples: Validate that title isnt empty, set timestamps, ask repo to save article, publish event to Rabbit.
- Repository: Filing Clerk, doesnt decide what should be saved, just saves what its told to save.
- Repository: Handles data persistence: EF Core, SQL query, database selection.
- Repository: Examples: Service says "store this in EU", repo picks the right DB Connection(via DB Selector) and executes EF Core operation.
- Interface: Job Descriptions, like if you are an IArticleRepo, you MUST be able to do bla bla bla.
- Interface: Provides contracts between layers for flexibility, testability and maintainability.
- Interface: Notes: Easier to replace EF Core should it be necessary, can mock them in testing.

Communication:
- Controller: "Hey Lars, I got a request for Europe"
- Service: "Cool, let me validate and prepare the article"
- Repo: "Okay, I will save it in Europes DB"
- Interface: "I am just watching, ignore me"


To see my DB running after docker-compose up -d:
- docker exec -it <sqlserver-container-name> /opt/mssql-tools/bin/sqlcmd \ -S localhost -U sa -P $SA_PASSWORD
- List DB: SELECT Name FROM sys.Databases;

logging
- Trace: Entering/exiting methods, payloads, EF Core Queries(Debugging)
- Information: Draft created, updated, deleted.
- Warning: Unexpected but non fatal, like missing fields.
- Error: Exceptions, failed DB Operations, failed HTTP calls to other services.
- Critical: Service crash, DB down, unrecoverable errors.
- Note: Dont log passwords and sensitive data.
- Auto cleaning?: Central Log Aggregator(Elasticsearch, Seq, Splunk), Rolling file logs(Serilog)

Running a Service in root: 
DraftService: docker build -t happyheadlines/draft-service -f src/DraftService/Dockerfile .

Run container: docker run -d -p 5001:8080 happyheadlines/draft-service - Gives a container name in the form of a long number.
Check logs: docker logs number = Shows active apps

// Current
My connect is established with sql server, but then an error occurs when SQL server expects encryption and my Docker
container doesnt trust the server certificate. It fails the handshake.

Trying to add TrustServerCertificate=True to builder.Services.AddDbContext


docker build -t happyheadlines/draft-service -f src/DraftService/Dockerfile .
docker-compose up --build draft-service sqlserver
docker run -d -p 5001:8080 happyheadlines/draft-service