The overall todo
- C4 Diagram - Done
- Implement ArticleService with CRUD and REST API and x-axis with 3 instances and load balancer - Done
- Implement ArticleDatabase and y-axis so each continent has own DB + a global DB - Done
- Implement CommentService. Fault Isolated with swimlanes. Takes over if Profanity Fails - Done
- Implement CommentDatabase - Done
- Implement ProfanityService. Fault Isolated with swimlanes - Done
- Implement ProfanityDatabase.  - Done
- Implement Draftservice with logging and tracing. - Done
- Implement DraftDatabase with logging and tracing. - Done
- Log and trace in central repo that is reuseable across entire architecture. - Done
- Add automatic cleaning of logs. - Not started
- Implement PublisherService with focus on distributed tracing. - Done
- Implement NewsletterService with focus on distributed tracing. - Done
- Implement ArticleQueue - Done
- Implement ArticleCache using offline process to periodically fill cache with articles from latest 14 days. - Done
- Implement CommentCache using cache miss approach to fill cache.  - Done
- Use Redis, because I want to learn how to use it. - Done
-----
- C4 Diagram for all 4 levels
- Make Dashboard that shows cache-hit-ratio of the CommentCache and ArticleCache - Saturday
- Implement proper connection to articles based on continents. - Saturday
- Need proper ProfanityDB with bad words. - Saturday
- Make more logs and consider what logs are should have, would have and wont have - Saturday
- Test if ArticleQueue works. - Sunday
- Test DraftService - Saturday
- Test PublisherService - Saturday
- Test SubscriberService - Saturday
- Test NewsletterService - Saturday
- Test Serilog - Sunday
- Test Zipkin - Sunday
- Test Seq - Sunday
- Create the README - Sunday
- Create the presentation


Commands
- docker-compose up -d = Makes sure docker compose grabs the environment.
- docker exec -it <sqlserver-container-name> /opt/mssql-tools/bin/sqlcmd \ -S localhost -U sa -P $SA_PASSWORD = To see the Db running
- Select Name From sys.Databases; = List DB.
- docker build -t happyheadlines/article-service -f src/ArticleService/Dockerfile . = run ArticleService in root.
- docker build -t happyheadlines/comment-service -f src/CommentService/Dockerfile . = run CommentService in root.
- docker build -t happyheadlines/profanity-service -f src/ProfanityService/Dockerfile . = run ProfanityService in root.
- docker build -t happyheadlines/draft-service -f src/DraftService/Dockerfile . = run DraftService in root.
- docker build -t happyheadlines/publisher-service -f src/PublisherService/Dockerfile . = run PublisherService in root.
- docker build -t happyheadlines/newsletter-service -f src/NewsletterService/Dockerfile . = run NewsletterService in root.
- docker build -t happyheadlines/subscriber-service -f src/SubscriberService/Dockerfile . = run SubscriberService in root.
- docker run -docker run -d -p 5001:8080 happyheadlines/draft-service = to be run after docker build
- docker-compose up --build = Runs the entire docker compose, aka if 1 service doesnt work, this wont launch.
- docker-compose up --build draft-service sqlserver = Runs the draft service through docker compose file and sqlserver.
- docker-compose down = Disables the entire docker compose file.
- docker logs containername = Shows the trace and error logs.
- docker stop containername = Stop a container.
- netstat -ano | findstr :8001 = To see if anything runs on 8001 port.
- dotnet add package prometheus-net.AspNetCore

Webapp: Publish an article.
PublisherService: Handles the publishing of articles, sends to ArticleQueue.
ArticleQueue: When an article is being published, the article enters the queue.
NewsletterService: Sends out newsletters to subscribers.
NewsletterService: Subscribes to ArticleQueue to receive the latest news first for immediate newsletter.
NewsletterService: Requests articles from ArticleService for daily newsletter, ArticleService fetch/stores articles in ArtibleDB.
ArticleService: Subscribes to ArticleQueue for the latest articles in order to persist them in a database.

Rewriting of the architecture
- Controller: The front desk, receives request, checks if valid and passes it to the right department.
- Controller: Deals with HTTP: Routing, query/body passing, response codes. 
- Controller: If client calls Post Articles, controller takes the ArticleDto from the body and gives it to the service.
- Service: The Manager, knows how to get work done, doesnt talk to DB directly, delegates to repo.
- Service: Business logic: rules, orchestration, validation.
- Service: Examples: Validate that title isnt empty, set timestamps, ask repo to save article, publish event to Rabbit.
- Repository: Filing Clerk, doesnt decide what should be saved, just saves what its told to save.
- Repository: Handles data persistence: EF Core, SQL query, database selection.
- Repository: Examples: Service says "store this in EU", repo picks the right DB Connection(via DB Selector) and executes EF Core operation.
- Interface: Job Descriptions, like if you are an IArticleRepo, you MUST be able to do bla bla bla.
- Interface: Provides contracts between layers for flexibility, testability and maintainability.
- Interface: Notes: Easier to replace EF Core should it be necessary, can mock them in testing.



logging
- Trace: Entering/exiting methods, payloads, EF Core Queries(Debugging)
- Information: Draft created, updated, deleted.
- Warning: Unexpected but non fatal, like missing fields.
- Error: Exceptions, failed DB Operations, failed HTTP calls to other services.
- Critical: Service crash, DB down, unrecoverable errors.
- Note: Dont log passwords and sensitive data.
- Auto cleaning?: Central Log Aggregator(Elasticsearch, Seq, Splunk), Rolling file logs(Serilog)

Running a Service in root: 
DraftService: docker build -t happyheadlines/draft-service -f src/DraftService/Dockerfile .

Run container: docker run -d -p 5001:8080 happyheadlines/draft-service - Gives a container name in the form of a long number.
Check logs: docker logs number = Shows active apps


// Current ArticleService
Communication with Docker works.
Tested and passed for ArticleCache before Repo is used.
Test if ArticleQueue works.

// Current CommentService
Communication with Docker works.
Tested and passed for CommentCache before Repo is used.

// Current ProfanityService
Communication with Docker works.
CircuitBreaker, if it fails, CommentService takes over.
Tested and passed for Profanity Shutdown and Comment takes over.

// Current DraftService
Communication with Docker works.
Communication with Swagger works.
May need some dummy data to properly test. It struggles with Posting.
Logging and tracing has been finished, need to test.
Make mock data for testing.

// PublisherService
Communication with Docker works.
Added Distributed tracing
Make mock data for testing.

// NewsletterService
Communication with Docker works.
Added Distributed tracing.
Make mock data for testing.

// SubscriberService
Communication with Docker works.

// Shared
Contains the DTOs
Contains the RabbitHelper
Contains RedisHelper and IRedisHelper
Contains LoggingHelper
Contains the ArticleQueue

// Testing
Has 3 Tests - All Pass



docker build -t happyheadlines/draft-service -f src/DraftService/Dockerfile .
docker-compose up --build draft-service sqlserver
docker run -d -p 5001:8080 happyheadlines/draft-service